Input/Output Name Generators & Globbing
=======================================

Pake can accept callables as task inputs, this is how :py:meth:`pake.glob` and :py:meth:`pake.pattern` are
implemented under the hood.  They both take the pattern you give them and return a new function, which
generates an iterable of input/output file names.

Input and output generators will work with both the :py:meth:`pake.Pake.task` function
decorator, as well as the :py:meth:`pake.Pake.add_task` method.

The evaluation of input/output generators is deferred until the task runs.

The reasoning behind the deferred evaluation is that input generators such as :py:meth:`pake.glob`
can have access to files generated by a tasks dependencies when evaluation is deferred until the task runs.
Because all the dependencies of the task will have been built by that point.

The outputs of input/output generators are passed through pake's change detection algorithm
once the values have been retrieved from them, to determine if the task should run or not.


:py:meth:`pake.glob` and :py:meth:`pake.pattern` are implemented like this:


.. code-block:: python

    def glob(pattern):

        def input_generator():

            # Input generators can return generators or lists.
            # as long as whatever the input generator returns
            # is an iterable object that produces file/directory
            # names as strings, it will work.

            return glob.iglob(expression, recursive=True)

        return input_generator


    # pattern generates a callable that you can
    # pass as a pake output, into the "i" parameter
    # of the task decorator, or even to the "inputs"
    # parameter of pk.add_task

    def pattern(file_pattern):

        def output_generator(inputs):

            # output generators receive the inputs
            # provided to the task, even ones that
            # were generated by an input generator

            # inputs is always a flat list, and a copy

            # inputs is safe to mutate if you want

            # As with input generators, you can return
            # any type of iterable that produces file/directory
            # names as strings and it will work.

            for inp in inputs:
                dir = os.path.dirname(inp)
                name, ext = os.path.splitext(os.path.basename(inp))
                yield file_pattern.replace('{dir}', dir).replace('%', name).replace('{ext}', ext)

        return output_generator


:py:meth:`pake.glob` and :py:meth:`pake.pattern` are used like this:


.. code-block:: python

    import pake

    pk = pake.init()

    @pk.task(i=pake.glob('src/*.c'), o=pake.pattern('bin/%.o'))
    def build_c(ctx):

        # Your going to have an equal number of
        # inputs and outputs in this task, because
        # the output names are being generated from
        # the input names

        for i, o in ctx.outdated_pairs:
            ctx.call('gcc', '-c', i, '-o', o)

    pake.run(pk, tasks=build_c)


Multiple input generators at once
---------------------------------

You can place input generators into a list or any other iterable such as a tuple,
pake will combine the values that they generate into one flat list.  You can also
use input generator callables along side plain old file or directory references.

Multiple output generators are not allowed however, you may only ever use
one output generator callable at a time, and you cannot use output generators
along side regular file/directory names.

Output generators process all of the tasks input file/directory names, and
are expected to return all of the tasks outputs.


Multiple Input Generator Example:


.. code-block:: python

    import pake

    pk = pake.init()

    # This task collects .c files from two directories
    # ('src_one' and 'src_two'), and compiles them all
    # together with 'main.c' (which exists in the current directory).

    # This task produces an executable file called 'main'

    @pk.task(i=[pake.glob('src_one/*.c'), pake.glob('src_two/*.c'), 'main.c'], o='main')
    def build_c(ctx):
        ctx.call('gcc', ctx.inputs, '-o', ctx.outputs)


    pake.run(pk, tasks=build_c)



Example with an output generator:


.. code-block:: python

    import pake

    pk = pake.init()

    # This task collects .c files from two directories
    # ('src_one' and 'src_two'), and compiles object files
    # that are created in each source directory along side
    # the source file.

    @pk.task(i=[pake.glob('src_one/*.c'), pake.glob('src_two/*.c')], o=pake.pattern('{dir}/%.o'))
    def build_c(ctx):

        # Your going to have an equal number of
        # inputs and outputs in this task, because
        # the output names are being generated from
        # the input names

        for i, o in ctx.outdated_pairs:
            ctx.call('gcc', '-c', i, '-o', o)


    pake.run(pk, tasks=build_c)


